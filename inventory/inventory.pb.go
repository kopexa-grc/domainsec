// Copyright (c) Kopexa GmbH.
// SPDX-License-Identifier: BUSL-1.1

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.7
// 	protoc        v5.29.3
// source: inventory.proto

package inventory

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ProtocolKind int32

const (
	ProtocolKind_PROTOCOL_UNSPECIFIED ProtocolKind = 0
	ProtocolKind_PROTOCOL_TCP         ProtocolKind = 1
	ProtocolKind_PROTOCOL_UDP         ProtocolKind = 2
)

// Enum value maps for ProtocolKind.
var (
	ProtocolKind_name = map[int32]string{
		0: "PROTOCOL_UNSPECIFIED",
		1: "PROTOCOL_TCP",
		2: "PROTOCOL_UDP",
	}
	ProtocolKind_value = map[string]int32{
		"PROTOCOL_UNSPECIFIED": 0,
		"PROTOCOL_TCP":         1,
		"PROTOCOL_UDP":         2,
	}
)

func (x ProtocolKind) Enum() *ProtocolKind {
	p := new(ProtocolKind)
	*p = x
	return p
}

func (x ProtocolKind) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProtocolKind) Descriptor() protoreflect.EnumDescriptor {
	return file_inventory_proto_enumTypes[0].Descriptor()
}

func (ProtocolKind) Type() protoreflect.EnumType {
	return &file_inventory_proto_enumTypes[0]
}

func (x ProtocolKind) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ProtocolKind.Descriptor instead.
func (ProtocolKind) EnumDescriptor() ([]byte, []int) {
	return file_inventory_proto_rawDescGZIP(), []int{0}
}

// Wappalyzer
type TechnologyDetail struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Description   string                 `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"` // Description of the application
	Website       string                 `protobuf:"bytes,2,opt,name=website,proto3" json:"website,omitempty"`         // Website of the application
	Cpe           string                 `protobuf:"bytes,3,opt,name=cpe,proto3" json:"cpe,omitempty"`                 // Common Platform Enumeration (CPE) identifier
	Icon          string                 `protobuf:"bytes,4,opt,name=icon,proto3" json:"icon,omitempty"`               // Base64 encoded icon of the application
	Categories    []string               `protobuf:"bytes,5,rep,name=categories,proto3" json:"categories,omitempty"`   // Categories the application belongs to
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TechnologyDetail) Reset() {
	*x = TechnologyDetail{}
	mi := &file_inventory_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TechnologyDetail) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TechnologyDetail) ProtoMessage() {}

func (x *TechnologyDetail) ProtoReflect() protoreflect.Message {
	mi := &file_inventory_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TechnologyDetail.ProtoReflect.Descriptor instead.
func (*TechnologyDetail) Descriptor() ([]byte, []int) {
	return file_inventory_proto_rawDescGZIP(), []int{0}
}

func (x *TechnologyDetail) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *TechnologyDetail) GetWebsite() string {
	if x != nil {
		return x.Website
	}
	return ""
}

func (x *TechnologyDetail) GetCpe() string {
	if x != nil {
		return x.Cpe
	}
	return ""
}

func (x *TechnologyDetail) GetIcon() string {
	if x != nil {
		return x.Icon
	}
	return ""
}

func (x *TechnologyDetail) GetCategories() []string {
	if x != nil {
		return x.Categories
	}
	return nil
}

type Port struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Port          int64                  `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`        // Port number
	Protocol      string                 `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"` // Protocol used (e.g., "tcp", "udp")
	Tls           bool                   `protobuf:"varint,3,opt,name=tls,proto3" json:"tls,omitempty"`          // Indicates if the port is using TLS
	ProtocolKind  ProtocolKind           `protobuf:"varint,10,opt,name=protocol_kind,json=protocolKind,proto3,enum=domainsec.inventory.v1.ProtocolKind" json:"protocol_kind,omitempty"`
	TlsInfo       *TLSInfo               `protobuf:"bytes,11,opt,name=tls_info,json=tlsInfo,proto3" json:"tls_info,omitempty"`
	ServiceName   string                 `protobuf:"bytes,12,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"` // e.g., http, ssh, smtp
	Banner        string                 `protobuf:"bytes,13,opt,name=banner,proto3" json:"banner,omitempty"`                              // raw or normalized banner
	Attributes    map[string]string      `protobuf:"bytes,14,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Port) Reset() {
	*x = Port{}
	mi := &file_inventory_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Port) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Port) ProtoMessage() {}

func (x *Port) ProtoReflect() protoreflect.Message {
	mi := &file_inventory_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Port.ProtoReflect.Descriptor instead.
func (*Port) Descriptor() ([]byte, []int) {
	return file_inventory_proto_rawDescGZIP(), []int{1}
}

func (x *Port) GetPort() int64 {
	if x != nil {
		return x.Port
	}
	return 0
}

func (x *Port) GetProtocol() string {
	if x != nil {
		return x.Protocol
	}
	return ""
}

func (x *Port) GetTls() bool {
	if x != nil {
		return x.Tls
	}
	return false
}

func (x *Port) GetProtocolKind() ProtocolKind {
	if x != nil {
		return x.ProtocolKind
	}
	return ProtocolKind_PROTOCOL_UNSPECIFIED
}

func (x *Port) GetTlsInfo() *TLSInfo {
	if x != nil {
		return x.TlsInfo
	}
	return nil
}

func (x *Port) GetServiceName() string {
	if x != nil {
		return x.ServiceName
	}
	return ""
}

func (x *Port) GetBanner() string {
	if x != nil {
		return x.Banner
	}
	return ""
}

func (x *Port) GetAttributes() map[string]string {
	if x != nil {
		return x.Attributes
	}
	return nil
}

type HostEntry struct {
	state             protoimpl.MessageState       `protogen:"open.v1"`
	Domain            string                       `protobuf:"bytes,1,opt,name=domain,proto3" json:"domain,omitempty"`
	Source            string                       `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	Host              string                       `protobuf:"bytes,3,opt,name=host,proto3" json:"host,omitempty"`
	ContentType       string                       `protobuf:"bytes,4,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	CdnName           string                       `protobuf:"bytes,5,opt,name=cdn_name,json=cdnName,proto3" json:"cdn_name,omitempty"`
	CdnType           string                       `protobuf:"bytes,6,opt,name=cdn_type,json=cdnType,proto3" json:"cdn_type,omitempty"`
	Webserver         string                       `protobuf:"bytes,7,opt,name=webserver,proto3" json:"webserver,omitempty"`
	Technologies      []string                     `protobuf:"bytes,8,rep,name=technologies,proto3" json:"technologies,omitempty"`
	StatusCode        int32                        `protobuf:"varint,9,opt,name=status_code,json=statusCode,proto3" json:"status_code,omitempty"`
	Err               string                       `protobuf:"bytes,10,opt,name=err,proto3" json:"err,omitempty"` // Error message if any
	Sni               string                       `protobuf:"bytes,11,opt,name=sni,proto3" json:"sni,omitempty"`
	Title             string                       `protobuf:"bytes,13,opt,name=title,proto3" json:"title,omitempty"`
	Scheme            string                       `protobuf:"bytes,14,opt,name=scheme,proto3" json:"scheme,omitempty"`
	ARecords          []string                     `protobuf:"bytes,15,rep,name=a_records,json=aRecords,proto3" json:"a_records,omitempty"`
	AaaaRecords       []string                     `protobuf:"bytes,16,rep,name=aaaa_records,json=aaaaRecords,proto3" json:"aaaa_records,omitempty"`
	Cdn               bool                         `protobuf:"varint,17,opt,name=cdn,proto3" json:"cdn,omitempty"`                                                                                                                               // Indicates if the host is behind a CDN
	ScreenshotBytes   []byte                       `protobuf:"bytes,18,opt,name=screenshot_bytes,json=screenshotBytes,proto3" json:"screenshot_bytes,omitempty"`                                                                                 // Base64 encoded screenshot bytes
	TechnologyDetails map[string]*TechnologyDetail `protobuf:"bytes,19,rep,name=technology_details,json=technologyDetails,proto3" json:"technology_details,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // W
	Cnames            []string                     `protobuf:"bytes,20,rep,name=cnames,proto3" json:"cnames,omitempty"`
	Ports             []*Port                      `protobuf:"bytes,21,rep,name=ports,proto3" json:"ports,omitempty"` // List of ports associated with the host
	// HTTP details to score posture/compliance
	FinalUrl     string       `protobuf:"bytes,24,opt,name=final_url,json=finalUrl,proto3" json:"final_url,omitempty"` // after redirects
	RedirectHops int32        `protobuf:"varint,25,opt,name=redirect_hops,json=redirectHops,proto3" json:"redirect_hops,omitempty"`
	HttpHeaders  *HTTPHeaders `protobuf:"bytes,26,opt,name=http_headers,json=httpHeaders,proto3" json:"http_headers,omitempty"`
	// DNS metadata (optional TTLs help debugging)
	ATtls                []int64           `protobuf:"varint,27,rep,packed,name=a_ttls,json=aTtls,proto3" json:"a_ttls,omitempty"` // align with a_records index
	AaaaTtls             []int64           `protobuf:"varint,28,rep,packed,name=aaaa_ttls,json=aaaaTtls,proto3" json:"aaaa_ttls,omitempty"`
	CnameTtls            []int64           `protobuf:"varint,29,rep,packed,name=cname_ttls,json=cnameTtls,proto3" json:"cname_ttls,omitempty"`
	LoginFormDetected    bool              `protobuf:"varint,30,opt,name=login_form_detected,json=loginFormDetected,proto3" json:"login_form_detected,omitempty"`          // useful for privacy/security checks
	CookiesOverHttp      bool              `protobuf:"varint,31,opt,name=cookies_over_http,json=cookiesOverHttp,proto3" json:"cookies_over_http,omitempty"`                // if seen, indicates risk
	MixedContentDetected bool              `protobuf:"varint,32,opt,name=mixed_content_detected,json=mixedContentDetected,proto3" json:"mixed_content_detected,omitempty"` // for CSP/HSTS posture
	Labels               map[string]string `protobuf:"bytes,40,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Metadata             map[string]string `protobuf:"bytes,41,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	TlsInfo              *TLSInfo          `protobuf:"bytes,42,opt,name=tls_info,json=tlsInfo,proto3" json:"tls_info,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *HostEntry) Reset() {
	*x = HostEntry{}
	mi := &file_inventory_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HostEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HostEntry) ProtoMessage() {}

func (x *HostEntry) ProtoReflect() protoreflect.Message {
	mi := &file_inventory_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HostEntry.ProtoReflect.Descriptor instead.
func (*HostEntry) Descriptor() ([]byte, []int) {
	return file_inventory_proto_rawDescGZIP(), []int{2}
}

func (x *HostEntry) GetDomain() string {
	if x != nil {
		return x.Domain
	}
	return ""
}

func (x *HostEntry) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *HostEntry) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *HostEntry) GetContentType() string {
	if x != nil {
		return x.ContentType
	}
	return ""
}

func (x *HostEntry) GetCdnName() string {
	if x != nil {
		return x.CdnName
	}
	return ""
}

func (x *HostEntry) GetCdnType() string {
	if x != nil {
		return x.CdnType
	}
	return ""
}

func (x *HostEntry) GetWebserver() string {
	if x != nil {
		return x.Webserver
	}
	return ""
}

func (x *HostEntry) GetTechnologies() []string {
	if x != nil {
		return x.Technologies
	}
	return nil
}

func (x *HostEntry) GetStatusCode() int32 {
	if x != nil {
		return x.StatusCode
	}
	return 0
}

func (x *HostEntry) GetErr() string {
	if x != nil {
		return x.Err
	}
	return ""
}

func (x *HostEntry) GetSni() string {
	if x != nil {
		return x.Sni
	}
	return ""
}

func (x *HostEntry) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *HostEntry) GetScheme() string {
	if x != nil {
		return x.Scheme
	}
	return ""
}

func (x *HostEntry) GetARecords() []string {
	if x != nil {
		return x.ARecords
	}
	return nil
}

func (x *HostEntry) GetAaaaRecords() []string {
	if x != nil {
		return x.AaaaRecords
	}
	return nil
}

func (x *HostEntry) GetCdn() bool {
	if x != nil {
		return x.Cdn
	}
	return false
}

func (x *HostEntry) GetScreenshotBytes() []byte {
	if x != nil {
		return x.ScreenshotBytes
	}
	return nil
}

func (x *HostEntry) GetTechnologyDetails() map[string]*TechnologyDetail {
	if x != nil {
		return x.TechnologyDetails
	}
	return nil
}

func (x *HostEntry) GetCnames() []string {
	if x != nil {
		return x.Cnames
	}
	return nil
}

func (x *HostEntry) GetPorts() []*Port {
	if x != nil {
		return x.Ports
	}
	return nil
}

func (x *HostEntry) GetFinalUrl() string {
	if x != nil {
		return x.FinalUrl
	}
	return ""
}

func (x *HostEntry) GetRedirectHops() int32 {
	if x != nil {
		return x.RedirectHops
	}
	return 0
}

func (x *HostEntry) GetHttpHeaders() *HTTPHeaders {
	if x != nil {
		return x.HttpHeaders
	}
	return nil
}

func (x *HostEntry) GetATtls() []int64 {
	if x != nil {
		return x.ATtls
	}
	return nil
}

func (x *HostEntry) GetAaaaTtls() []int64 {
	if x != nil {
		return x.AaaaTtls
	}
	return nil
}

func (x *HostEntry) GetCnameTtls() []int64 {
	if x != nil {
		return x.CnameTtls
	}
	return nil
}

func (x *HostEntry) GetLoginFormDetected() bool {
	if x != nil {
		return x.LoginFormDetected
	}
	return false
}

func (x *HostEntry) GetCookiesOverHttp() bool {
	if x != nil {
		return x.CookiesOverHttp
	}
	return false
}

func (x *HostEntry) GetMixedContentDetected() bool {
	if x != nil {
		return x.MixedContentDetected
	}
	return false
}

func (x *HostEntry) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *HostEntry) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *HostEntry) GetTlsInfo() *TLSInfo {
	if x != nil {
		return x.TlsInfo
	}
	return nil
}

type HTTPHeaders struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Security headers that we care for GRC dashboards
	ContentSecurityPolicy   string `protobuf:"bytes,1,opt,name=content_security_policy,json=contentSecurityPolicy,proto3" json:"content_security_policy,omitempty"`
	StrictTransportSecurity string `protobuf:"bytes,2,opt,name=strict_transport_security,json=strictTransportSecurity,proto3" json:"strict_transport_security,omitempty"`
	XContentTypeOptions     string `protobuf:"bytes,3,opt,name=x_content_type_options,json=xContentTypeOptions,proto3" json:"x_content_type_options,omitempty"`
	XFrameOptions           string `protobuf:"bytes,4,opt,name=x_frame_options,json=xFrameOptions,proto3" json:"x_frame_options,omitempty"`
	ReferrerPolicy          string `protobuf:"bytes,5,opt,name=referrer_policy,json=referrerPolicy,proto3" json:"referrer_policy,omitempty"`
	PermissionsPolicy       string `protobuf:"bytes,6,opt,name=permissions_policy,json=permissionsPolicy,proto3" json:"permissions_policy,omitempty"`
	CrossOriginOpenerPolicy string `protobuf:"bytes,7,opt,name=cross_origin_opener_policy,json=crossOriginOpenerPolicy,proto3" json:"cross_origin_opener_policy,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *HTTPHeaders) Reset() {
	*x = HTTPHeaders{}
	mi := &file_inventory_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HTTPHeaders) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HTTPHeaders) ProtoMessage() {}

func (x *HTTPHeaders) ProtoReflect() protoreflect.Message {
	mi := &file_inventory_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HTTPHeaders.ProtoReflect.Descriptor instead.
func (*HTTPHeaders) Descriptor() ([]byte, []int) {
	return file_inventory_proto_rawDescGZIP(), []int{3}
}

func (x *HTTPHeaders) GetContentSecurityPolicy() string {
	if x != nil {
		return x.ContentSecurityPolicy
	}
	return ""
}

func (x *HTTPHeaders) GetStrictTransportSecurity() string {
	if x != nil {
		return x.StrictTransportSecurity
	}
	return ""
}

func (x *HTTPHeaders) GetXContentTypeOptions() string {
	if x != nil {
		return x.XContentTypeOptions
	}
	return ""
}

func (x *HTTPHeaders) GetXFrameOptions() string {
	if x != nil {
		return x.XFrameOptions
	}
	return ""
}

func (x *HTTPHeaders) GetReferrerPolicy() string {
	if x != nil {
		return x.ReferrerPolicy
	}
	return ""
}

func (x *HTTPHeaders) GetPermissionsPolicy() string {
	if x != nil {
		return x.PermissionsPolicy
	}
	return ""
}

func (x *HTTPHeaders) GetCrossOriginOpenerPolicy() string {
	if x != nil {
		return x.CrossOriginOpenerPolicy
	}
	return ""
}

type TLSInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Detected      bool                   `protobuf:"varint,1,opt,name=detected,proto3" json:"detected,omitempty"`
	Version       string                 `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"` // e.g., TLS1.2/TLS1.3
	Alpn          string                 `protobuf:"bytes,3,opt,name=alpn,proto3" json:"alpn,omitempty"`       // e.g., h2,http/1.1
	Cipher        string                 `protobuf:"bytes,4,opt,name=cipher,proto3" json:"cipher,omitempty"`
	CertIssuer    string                 `protobuf:"bytes,5,opt,name=cert_issuer,json=certIssuer,proto3" json:"cert_issuer,omitempty"`
	CertSubject   string                 `protobuf:"bytes,6,opt,name=cert_subject,json=certSubject,proto3" json:"cert_subject,omitempty"`
	CertSha256    string                 `protobuf:"bytes,7,opt,name=cert_sha256,json=certSha256,proto3" json:"cert_sha256,omitempty"`
	NotBefore     string                 `protobuf:"bytes,8,opt,name=not_before,json=notBefore,proto3" json:"not_before,omitempty"` // RFC3339
	NotAfter      string                 `protobuf:"bytes,9,opt,name=not_after,json=notAfter,proto3" json:"not_after,omitempty"`    // RFC3339
	Sans          []string               `protobuf:"bytes,10,rep,name=sans,proto3" json:"sans,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TLSInfo) Reset() {
	*x = TLSInfo{}
	mi := &file_inventory_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TLSInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TLSInfo) ProtoMessage() {}

func (x *TLSInfo) ProtoReflect() protoreflect.Message {
	mi := &file_inventory_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TLSInfo.ProtoReflect.Descriptor instead.
func (*TLSInfo) Descriptor() ([]byte, []int) {
	return file_inventory_proto_rawDescGZIP(), []int{4}
}

func (x *TLSInfo) GetDetected() bool {
	if x != nil {
		return x.Detected
	}
	return false
}

func (x *TLSInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *TLSInfo) GetAlpn() string {
	if x != nil {
		return x.Alpn
	}
	return ""
}

func (x *TLSInfo) GetCipher() string {
	if x != nil {
		return x.Cipher
	}
	return ""
}

func (x *TLSInfo) GetCertIssuer() string {
	if x != nil {
		return x.CertIssuer
	}
	return ""
}

func (x *TLSInfo) GetCertSubject() string {
	if x != nil {
		return x.CertSubject
	}
	return ""
}

func (x *TLSInfo) GetCertSha256() string {
	if x != nil {
		return x.CertSha256
	}
	return ""
}

func (x *TLSInfo) GetNotBefore() string {
	if x != nil {
		return x.NotBefore
	}
	return ""
}

func (x *TLSInfo) GetNotAfter() string {
	if x != nil {
		return x.NotAfter
	}
	return ""
}

func (x *TLSInfo) GetSans() []string {
	if x != nil {
		return x.Sans
	}
	return nil
}

var File_inventory_proto protoreflect.FileDescriptor

const file_inventory_proto_rawDesc = "" +
	"\n" +
	"\x0finventory.proto\x12\x16domainsec.inventory.v1\"\x94\x01\n" +
	"\x10TechnologyDetail\x12 \n" +
	"\vdescription\x18\x01 \x01(\tR\vdescription\x12\x18\n" +
	"\awebsite\x18\x02 \x01(\tR\awebsite\x12\x10\n" +
	"\x03cpe\x18\x03 \x01(\tR\x03cpe\x12\x12\n" +
	"\x04icon\x18\x04 \x01(\tR\x04icon\x12\x1e\n" +
	"\n" +
	"categories\x18\x05 \x03(\tR\n" +
	"categories\"\x97\x03\n" +
	"\x04Port\x12\x12\n" +
	"\x04port\x18\x01 \x01(\x03R\x04port\x12\x1a\n" +
	"\bprotocol\x18\x02 \x01(\tR\bprotocol\x12\x10\n" +
	"\x03tls\x18\x03 \x01(\bR\x03tls\x12I\n" +
	"\rprotocol_kind\x18\n" +
	" \x01(\x0e2$.domainsec.inventory.v1.ProtocolKindR\fprotocolKind\x12:\n" +
	"\btls_info\x18\v \x01(\v2\x1f.domainsec.inventory.v1.TLSInfoR\atlsInfo\x12!\n" +
	"\fservice_name\x18\f \x01(\tR\vserviceName\x12\x16\n" +
	"\x06banner\x18\r \x01(\tR\x06banner\x12L\n" +
	"\n" +
	"attributes\x18\x0e \x03(\v2,.domainsec.inventory.v1.Port.AttributesEntryR\n" +
	"attributes\x1a=\n" +
	"\x0fAttributesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xb6\v\n" +
	"\tHostEntry\x12\x16\n" +
	"\x06domain\x18\x01 \x01(\tR\x06domain\x12\x16\n" +
	"\x06source\x18\x02 \x01(\tR\x06source\x12\x12\n" +
	"\x04host\x18\x03 \x01(\tR\x04host\x12!\n" +
	"\fcontent_type\x18\x04 \x01(\tR\vcontentType\x12\x19\n" +
	"\bcdn_name\x18\x05 \x01(\tR\acdnName\x12\x19\n" +
	"\bcdn_type\x18\x06 \x01(\tR\acdnType\x12\x1c\n" +
	"\twebserver\x18\a \x01(\tR\twebserver\x12\"\n" +
	"\ftechnologies\x18\b \x03(\tR\ftechnologies\x12\x1f\n" +
	"\vstatus_code\x18\t \x01(\x05R\n" +
	"statusCode\x12\x10\n" +
	"\x03err\x18\n" +
	" \x01(\tR\x03err\x12\x10\n" +
	"\x03sni\x18\v \x01(\tR\x03sni\x12\x14\n" +
	"\x05title\x18\r \x01(\tR\x05title\x12\x16\n" +
	"\x06scheme\x18\x0e \x01(\tR\x06scheme\x12\x1b\n" +
	"\ta_records\x18\x0f \x03(\tR\baRecords\x12!\n" +
	"\faaaa_records\x18\x10 \x03(\tR\vaaaaRecords\x12\x10\n" +
	"\x03cdn\x18\x11 \x01(\bR\x03cdn\x12)\n" +
	"\x10screenshot_bytes\x18\x12 \x01(\fR\x0fscreenshotBytes\x12g\n" +
	"\x12technology_details\x18\x13 \x03(\v28.domainsec.inventory.v1.HostEntry.TechnologyDetailsEntryR\x11technologyDetails\x12\x16\n" +
	"\x06cnames\x18\x14 \x03(\tR\x06cnames\x122\n" +
	"\x05ports\x18\x15 \x03(\v2\x1c.domainsec.inventory.v1.PortR\x05ports\x12\x1b\n" +
	"\tfinal_url\x18\x18 \x01(\tR\bfinalUrl\x12#\n" +
	"\rredirect_hops\x18\x19 \x01(\x05R\fredirectHops\x12F\n" +
	"\fhttp_headers\x18\x1a \x01(\v2#.domainsec.inventory.v1.HTTPHeadersR\vhttpHeaders\x12\x15\n" +
	"\x06a_ttls\x18\x1b \x03(\x03R\x05aTtls\x12\x1b\n" +
	"\taaaa_ttls\x18\x1c \x03(\x03R\baaaaTtls\x12\x1d\n" +
	"\n" +
	"cname_ttls\x18\x1d \x03(\x03R\tcnameTtls\x12.\n" +
	"\x13login_form_detected\x18\x1e \x01(\bR\x11loginFormDetected\x12*\n" +
	"\x11cookies_over_http\x18\x1f \x01(\bR\x0fcookiesOverHttp\x124\n" +
	"\x16mixed_content_detected\x18  \x01(\bR\x14mixedContentDetected\x12E\n" +
	"\x06labels\x18( \x03(\v2-.domainsec.inventory.v1.HostEntry.LabelsEntryR\x06labels\x12K\n" +
	"\bmetadata\x18) \x03(\v2/.domainsec.inventory.v1.HostEntry.MetadataEntryR\bmetadata\x12:\n" +
	"\btls_info\x18* \x01(\v2\x1f.domainsec.inventory.v1.TLSInfoR\atlsInfo\x1an\n" +
	"\x16TechnologyDetailsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12>\n" +
	"\x05value\x18\x02 \x01(\v2(.domainsec.inventory.v1.TechnologyDetailR\x05value:\x028\x01\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xf3\x02\n" +
	"\vHTTPHeaders\x126\n" +
	"\x17content_security_policy\x18\x01 \x01(\tR\x15contentSecurityPolicy\x12:\n" +
	"\x19strict_transport_security\x18\x02 \x01(\tR\x17strictTransportSecurity\x123\n" +
	"\x16x_content_type_options\x18\x03 \x01(\tR\x13xContentTypeOptions\x12&\n" +
	"\x0fx_frame_options\x18\x04 \x01(\tR\rxFrameOptions\x12'\n" +
	"\x0freferrer_policy\x18\x05 \x01(\tR\x0ereferrerPolicy\x12-\n" +
	"\x12permissions_policy\x18\x06 \x01(\tR\x11permissionsPolicy\x12;\n" +
	"\x1across_origin_opener_policy\x18\a \x01(\tR\x17crossOriginOpenerPolicy\"\xa0\x02\n" +
	"\aTLSInfo\x12\x1a\n" +
	"\bdetected\x18\x01 \x01(\bR\bdetected\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12\x12\n" +
	"\x04alpn\x18\x03 \x01(\tR\x04alpn\x12\x16\n" +
	"\x06cipher\x18\x04 \x01(\tR\x06cipher\x12\x1f\n" +
	"\vcert_issuer\x18\x05 \x01(\tR\n" +
	"certIssuer\x12!\n" +
	"\fcert_subject\x18\x06 \x01(\tR\vcertSubject\x12\x1f\n" +
	"\vcert_sha256\x18\a \x01(\tR\n" +
	"certSha256\x12\x1d\n" +
	"\n" +
	"not_before\x18\b \x01(\tR\tnotBefore\x12\x1b\n" +
	"\tnot_after\x18\t \x01(\tR\bnotAfter\x12\x12\n" +
	"\x04sans\x18\n" +
	" \x03(\tR\x04sans*L\n" +
	"\fProtocolKind\x12\x18\n" +
	"\x14PROTOCOL_UNSPECIFIED\x10\x00\x12\x10\n" +
	"\fPROTOCOL_TCP\x10\x01\x12\x10\n" +
	"\fPROTOCOL_UDP\x10\x02B'Z%github.com/kopexa/domainsec/inventoryb\x06proto3"

var (
	file_inventory_proto_rawDescOnce sync.Once
	file_inventory_proto_rawDescData []byte
)

func file_inventory_proto_rawDescGZIP() []byte {
	file_inventory_proto_rawDescOnce.Do(func() {
		file_inventory_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_inventory_proto_rawDesc), len(file_inventory_proto_rawDesc)))
	})
	return file_inventory_proto_rawDescData
}

var file_inventory_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_inventory_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_inventory_proto_goTypes = []any{
	(ProtocolKind)(0),        // 0: domainsec.inventory.v1.ProtocolKind
	(*TechnologyDetail)(nil), // 1: domainsec.inventory.v1.TechnologyDetail
	(*Port)(nil),             // 2: domainsec.inventory.v1.Port
	(*HostEntry)(nil),        // 3: domainsec.inventory.v1.HostEntry
	(*HTTPHeaders)(nil),      // 4: domainsec.inventory.v1.HTTPHeaders
	(*TLSInfo)(nil),          // 5: domainsec.inventory.v1.TLSInfo
	nil,                      // 6: domainsec.inventory.v1.Port.AttributesEntry
	nil,                      // 7: domainsec.inventory.v1.HostEntry.TechnologyDetailsEntry
	nil,                      // 8: domainsec.inventory.v1.HostEntry.LabelsEntry
	nil,                      // 9: domainsec.inventory.v1.HostEntry.MetadataEntry
}
var file_inventory_proto_depIdxs = []int32{
	0,  // 0: domainsec.inventory.v1.Port.protocol_kind:type_name -> domainsec.inventory.v1.ProtocolKind
	5,  // 1: domainsec.inventory.v1.Port.tls_info:type_name -> domainsec.inventory.v1.TLSInfo
	6,  // 2: domainsec.inventory.v1.Port.attributes:type_name -> domainsec.inventory.v1.Port.AttributesEntry
	7,  // 3: domainsec.inventory.v1.HostEntry.technology_details:type_name -> domainsec.inventory.v1.HostEntry.TechnologyDetailsEntry
	2,  // 4: domainsec.inventory.v1.HostEntry.ports:type_name -> domainsec.inventory.v1.Port
	4,  // 5: domainsec.inventory.v1.HostEntry.http_headers:type_name -> domainsec.inventory.v1.HTTPHeaders
	8,  // 6: domainsec.inventory.v1.HostEntry.labels:type_name -> domainsec.inventory.v1.HostEntry.LabelsEntry
	9,  // 7: domainsec.inventory.v1.HostEntry.metadata:type_name -> domainsec.inventory.v1.HostEntry.MetadataEntry
	5,  // 8: domainsec.inventory.v1.HostEntry.tls_info:type_name -> domainsec.inventory.v1.TLSInfo
	1,  // 9: domainsec.inventory.v1.HostEntry.TechnologyDetailsEntry.value:type_name -> domainsec.inventory.v1.TechnologyDetail
	10, // [10:10] is the sub-list for method output_type
	10, // [10:10] is the sub-list for method input_type
	10, // [10:10] is the sub-list for extension type_name
	10, // [10:10] is the sub-list for extension extendee
	0,  // [0:10] is the sub-list for field type_name
}

func init() { file_inventory_proto_init() }
func file_inventory_proto_init() {
	if File_inventory_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_inventory_proto_rawDesc), len(file_inventory_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_inventory_proto_goTypes,
		DependencyIndexes: file_inventory_proto_depIdxs,
		EnumInfos:         file_inventory_proto_enumTypes,
		MessageInfos:      file_inventory_proto_msgTypes,
	}.Build()
	File_inventory_proto = out.File
	file_inventory_proto_goTypes = nil
	file_inventory_proto_depIdxs = nil
}
